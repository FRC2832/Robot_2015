// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc2832.Robot_2015;

import com.kauailabs.nav6.frc.IMUAdvanced;

import edu.wpi.first.wpilibj.AnalogInput;
import edu.wpi.first.wpilibj.CANTalon;
import edu.wpi.first.wpilibj.CANTalon.ControlMode;
import edu.wpi.first.wpilibj.CANTalon.FeedbackDevice;
import edu.wpi.first.wpilibj.Compressor;
import edu.wpi.first.wpilibj.DigitalOutput;
import edu.wpi.first.wpilibj.DoubleSolenoid;
import edu.wpi.first.wpilibj.Gyro;
import edu.wpi.first.wpilibj.PowerDistributionPanel;
import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.SerialPort;
import edu.wpi.first.wpilibj.Solenoid;
import edu.wpi.first.wpilibj.Talon;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;

/**
 * The RobotMap is a mapping from the ports sensors and actuators are wired into
 * to a variable name. This provides flexibility changing wiring, makes checking
 * the wiring easier and significantly reduces the number of magic numbers
 * floating around.
 */
public class RobotMap {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    public static CANTalon driveBaseLeftFrontMotor;
    public static CANTalon driveBaseLeftRearMotor;
    public static CANTalon driveBaseRightFrontMotor;
    public static CANTalon driveBaseRightRearMotor;
    public static RobotDrive driveBaseDriveTrain;
    public static CANTalon forkliftMotor;
    public static Talon leftIngestor;
    public static Talon rightIngestor;
    public static Gyro driveBaseGyro;
    public static Compressor pneumaticsCompressor;
    public static AnalogInput pneumaticsPressure;
    public static DoubleSolenoid pneumaticsDoubleSolenoidFork;
    public static Solenoid pneumaticsSolenoidRight;
    public static Solenoid pneumaticsSolenoidLeft;
    public static DoubleSolenoid pneumaticsDoubleSolenoidCClamps;
    public static DoubleSolenoid pneumaticsDoubleSolenoidUpperClamp;
    public static IMUAdvanced imu;
    public static DigitalOutput lightRing;
	public static CANTalon talon5;
	public static PowerDistributionPanel pdp;
	
    public static final double ENCODER_PULSE_PER_METER = 2800;
    public static final double DRIVE_TRAIN_CONVERSION = 0.23 * ENCODER_PULSE_PER_METER;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    public static void init() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    	driveBaseLeftFrontMotor = new CANTalon(1);
        driveBaseLeftFrontMotor.changeControlMode(ControlMode.Speed);
        driveBaseLeftFrontMotor.setFeedbackDevice(FeedbackDevice.QuadEncoder);
        driveBaseLeftFrontMotor.setPID(0.75, 0.0, 0.0);
        
        driveBaseLeftRearMotor = new CANTalon(4);
        driveBaseLeftRearMotor.changeControlMode(ControlMode.Speed);
        driveBaseLeftRearMotor.setFeedbackDevice(FeedbackDevice.QuadEncoder);
        driveBaseLeftRearMotor.setPID(0.75, 0.0, 0.0);
        
        driveBaseRightFrontMotor = new CANTalon(2);
        driveBaseRightFrontMotor.changeControlMode(ControlMode.Speed);
        driveBaseRightFrontMotor.setFeedbackDevice(FeedbackDevice.QuadEncoder);
        driveBaseRightFrontMotor.setPID(0.75, 0.0, 0.0);
        
        driveBaseRightRearMotor = new CANTalon(3);
        driveBaseRightRearMotor.changeControlMode(ControlMode.Speed);
        driveBaseRightRearMotor.setFeedbackDevice(FeedbackDevice.QuadEncoder);
        driveBaseRightRearMotor.setPID(0.75, 0.0, 0.0);
        
        pdp = new PowerDistributionPanel();
        
        forkliftMotor = new CANTalon(5);
        forkliftMotor.changeControlMode(ControlMode.Position);

        forkliftMotor.setFeedbackDevice(FeedbackDevice.QuadEncoder);
        forkliftMotor.setPID(1.0, 0.0, 0.0);
        // Match the new gear box
        //forkliftMotor.reverseOutput(true);
        forkliftMotor.reverseOutput( false );
        
        // DCM: 24 was too low, hunted because couldn't hold position.
        // Might have worked if tuned up the PID.
        // forkliftMotor.setVoltageRampRate( 100.0 );  // Volts per second max change
        
        // Forklift needs to be inverted
        //forkliftMotor.reverseSensor(true);
        //forkliftMotor.setPosition( forkliftMotor.getPosition()); // "zero"; should be at bottom to begin with
        
        //KEEP THIS AT 250 SO IT GOES ALL THE WAY DOWN
        forkliftMotor.setPosition( 250 );
        forkliftMotor.disableControl();
        
        //enable normally closed limit switches
//        forkliftMotor.enableLimitSwitch(true, true);
//        forkliftMotor.ConfigFwdLimitSwitchNormallyOpen(false);
//        forkliftMotor.ConfigRevLimitSwitchNormallyOpen(false);
        // Just kiding. It broke.
        forkliftMotor.enableLimitSwitch(false, false);
        
        leftIngestor = new Talon(0);
        rightIngestor = new Talon(1);
        //driveBaseRightRearMotor.reverseOutput(true);
        //driveBaseRightFrontMotor.reverseOutput(true);
        
        driveBaseDriveTrain = new CANTalonRobotDrive(driveBaseLeftFrontMotor, driveBaseLeftRearMotor,
              driveBaseRightFrontMotor, driveBaseRightRearMotor);
        
        driveBaseDriveTrain.setSafetyEnabled(true);
        driveBaseDriveTrain.setExpiration(0.2);
        driveBaseDriveTrain.setSensitivity(0.5);
        driveBaseDriveTrain.setMaxOutput(1.0);
        // Doug: I had to invert the left side motors to get the competition robot to drive correctly
        // Why is that? When the right were inverted here and the left were not, the talons all were
        // being commanded in the same direction. Is there a different place in the code where we 
        // invert one side of the Talons?????
        // TODO: Verify that the encoders on the left side are counting in the correct direction now!!!!
        // DCM::: I backed out the above change. I don't know why.
        driveBaseDriveTrain.setInvertedMotor(RobotDrive.MotorType.kFrontRight, true);
        driveBaseDriveTrain.setInvertedMotor(RobotDrive.MotorType.kRearRight, true);
        driveBaseDriveTrain.setInvertedMotor(RobotDrive.MotorType.kRearLeft, false);
        driveBaseDriveTrain.setInvertedMotor(RobotDrive.MotorType.kFrontLeft, false);
        
        driveBaseGyro = new Gyro(0);
        LiveWindow.addSensor("DriveBase", "Gyro", driveBaseGyro);
        driveBaseGyro.setSensitivity(0.007);
        
        //Pneumatic Stuffs
        pneumaticsCompressor = new Compressor();
        
        pneumaticsPressure = new AnalogInput(1);
        
        pneumaticsDoubleSolenoidFork = new DoubleSolenoid(0, 3, 6);      
        LiveWindow.addActuator("Pneumatics", "Double Solenoid Fork", pneumaticsDoubleSolenoidFork);
        
        pneumaticsSolenoidRight = new Solenoid(0, 4);      
        LiveWindow.addActuator("Pneumatics", "Double Solenoid Right", pneumaticsSolenoidRight);
        
        pneumaticsSolenoidLeft = new Solenoid(0, 5);      
        LiveWindow.addActuator("Pneumatics", "Double Solenoid Left", pneumaticsSolenoidLeft);
        
        pneumaticsDoubleSolenoidCClamps = new DoubleSolenoid(0, 0, 1);      
        LiveWindow.addActuator("Pneumatics", "Double Solenoid CClamps", pneumaticsDoubleSolenoidCClamps);

        pneumaticsDoubleSolenoidUpperClamp = new DoubleSolenoid(0, 2, 7);      
        LiveWindow.addActuator("Pneumatics", "Double Solenoid Upper Clamp", pneumaticsDoubleSolenoidUpperClamp);


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

        byte update_rate_hz = 50;
        imu = new IMUAdvanced(new SerialPort(57600,SerialPort.Port.kMXP), update_rate_hz);
        imu.startLiveWindowMode();
        LiveWindow.addSensor("IMU", "Gyro", imu);
        
        lightRing = new DigitalOutput(9);
        

    }
	
}
