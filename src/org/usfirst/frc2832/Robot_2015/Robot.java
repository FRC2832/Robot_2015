// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc2832.Robot_2015;

import java.util.ArrayList;

import org.usfirst.frc2832.Robot_2015.commands.CloseFork;
import org.usfirst.frc2832.Robot_2015.commands.Instruction;
import org.usfirst.frc2832.Robot_2015.commands.MecanumFOD;
import org.usfirst.frc2832.Robot_2015.commands.MecanumROD;
import org.usfirst.frc2832.Robot_2015.commands.MoveDirection;
import org.usfirst.frc2832.Robot_2015.commands.OpenFork;
import org.usfirst.frc2832.Robot_2015.commands.auton.Global;
import org.usfirst.frc2832.Robot_2015.commands.auton.Pathable;
import org.usfirst.frc2832.Robot_2015.subsystems.DriveBase;
import org.usfirst.frc2832.Robot_2015.subsystems.LiftControl;
import org.usfirst.frc2832.Robot_2015.subsystems.Pneumatics;

import com.ni.vision.NIVision;
import com.ni.vision.NIVision.Image;

import edu.wpi.first.wpilibj.CANTalon;
import edu.wpi.first.wpilibj.CameraServer;
import edu.wpi.first.wpilibj.DoubleSolenoid;
import edu.wpi.first.wpilibj.IterativeRobot;
import edu.wpi.first.wpilibj.Preferences;
import edu.wpi.first.wpilibj.buttons.JoystickButton;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.command.Scheduler;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj.vision.USBCamera;


/**
 * The VM is configured to automatically run this class, and to call the
 * functions corresponding to each mode, as described in the IterativeRobot
 * documentation. If you change the name of this class or the package after
 * creating this project, you must also update the manifest file in the resource
 * directory.
 */
public class Robot extends IterativeRobot {

    Command autonomousCommand;
    Command mecanumFOD;
    Command mecanumROD;
    
    public static OI oi;
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    public static DriveBase driveBase;
    public static Pneumatics pneumatics;
    public static FieldLocation startPosition;
    public static FieldLocation endPosition;
    public static FieldLocation midPosition;
    
    public boolean povPressed = false;
    public boolean leftTriggerPressed = false;
    public boolean rightTriggerPressed = false;
    public JoystickButton back;
    public JoystickButton start;
    public boolean backPressed = false;
    public boolean startPressed = false;
    
    //enum to represent various control types
    public enum controlType {
    	automaticIngestors, manualIngestors;
    }
    public int currentControl = 1; //represents current control type from above enum
    
    
    public static final FieldLocation[] startPositions = new FieldLocation [] {
			new FieldLocation(1.15, 1.28,90),
			new FieldLocation(1.15, 2.75,-90),
			new FieldLocation(1.15, 3.35,90),
			new FieldLocation(1.15, 4.78,-90),
			new FieldLocation(1.15, 5.47,90),
			new FieldLocation(1.15, 6.89,-90)
	};
    
    public static CameraServer cs = null;
	private USBCamera camera = null;
    
    private ArrayList<Instruction> prevPath;
	private Image img;
    
    // SOMEBODY FIX THIS, THIS SHOULD BE LIFT SUBSYSTEM
    public static Subsystem lift = new Subsystem() {
		@Override
		protected void initDefaultCommand() {
			
		};
    };
    // THIS TOO
    public static Subsystem rollers = new Subsystem() {
		@Override
		protected void initDefaultCommand() {
			
		};
    };
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    /**
     * This function is run when the robot is first started up and should be
     * used for any initialization code.
     */
    public void robotInit() {
    	RobotMap.init();
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    	LiftControl.zeroValue = RobotMap.forkliftMotor.getPosition();
    	
    	driveBase = new DriveBase();
        pneumatics = new Pneumatics();
        
        img = NIVision.imaqCreateImage(NIVision.ImageType.IMAGE_RGB, 0);
        
    	RobotMap.forkliftMotor.disableControl();
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        // OI must be constructed after subsystems. If the OI creates Commands 
        //(which it very likely will), subsystems are not guaranteed to be 
        // constructed yet. Thus, their requires() statements may grab null 
        // pointers. Bad news. Don't move it.
        oi = new OI();
        
        back = new JoystickButton(oi.joystick, 7);
        start = new JoystickButton(oi.joystick, 8);
        
        try {
        	cs = CameraServer.getInstance();
	        cs.setQuality( 10 );
	        
/* The available size constants for cs.setSize are 0,1,2 for:
	private static final int kSize640x480 = 0;
    private static final int kSize320x240 = 1;
    private static final int kSize160x120 = 2;
*/
//	        cs.setSize( 1 );
	       
	        cs.startAutomaticCapture("cam0");
        } catch (Exception e) {
        	// No camera signal, ignore
        }
        
        RobotMap.lightRing.set(true);
    }

    /**
     * This function is called when the disabled button is hit.
     * You can use it to reset subsystems before shutting down.
     */
    public void disabledInit(){
    	RobotMap.forkliftMotor.disableControl();
    	RobotMap.forkliftMotor.set(0.0);
    	//RobotMap.forkliftMotor.enableBrakeMode(false);  //TODO: verify that this is how you do it
    	
    	RobotMap.driveBaseLeftFrontMotor.enableBrakeMode(false);
    	RobotMap.driveBaseRightFrontMotor.enableBrakeMode(false);
    	RobotMap.driveBaseLeftRearMotor.enableBrakeMode(false);
    	RobotMap.driveBaseRightRearMotor.enableBrakeMode(false);
    	
    	RobotMap.pneumaticsDoubleSolenoidCClamps.set(DoubleSolenoid.Value.kForward);
    	RobotMap.pneumaticsSolenoidRight.set(true);
    	RobotMap.pneumaticsSolenoidLeft.set(false);
    	//RobotMap.pneumaticsDoubleSolenoidFork.set(DoubleSolenoid.Value.kReverse);
       	RobotMap.pneumaticsDoubleSolenoidUpperClamp.set(DoubleSolenoid.Value.kReverse);
    }

    public void disabledPeriodic() {
        Scheduler.getInstance().removeAll();
        
        startPosition = startPositions[(int)oi.startPos.getSelected()];
        midPosition =  new FieldLocation(startPosition.x + Global.distToMidPos, startPosition.y,0);
        endPosition = new FieldLocation(startPosition.x + Global.distToEndPos, startPosition.y,0);
        
        ArrayList<Instruction> newPath = ((Pathable) oi.pattern.getSelected()).getPath();
        
        SmartDashboard.putNumber("Gyro Reading", RobotMap.imu.getYaw());
        
        
        // Note: This code causes issues on FMS
        // Update if changed
        /*if ((prevPath == null || newPath.hashCode() != prevPath.hashCode()) && !cs.isAutoCaptureStarted()) {
        	cs.setImage(PathVisualizer.makeImage(newPath));
        }*/
        
        prevPath = newPath;
    }

    public void autonomousInit() {
        // schedule the autonomous command
    	//RobotMap.forkliftMotor.enableBrakeMode(true);  //TODO: verify that this is how you do it 
    	
    	/*
    	 * RobotMap.driveBaseLeftFrontMotor.enableBrakeMode(true);
    	 * RobotMap.driveBaseRightFrontMotor.enableBrakeMode(true);
    	RobotMap.driveBaseLeftRearMotor.enableBrakeMode(true);
    	RobotMap.driveBaseRightRearMotor.enableBrakeMode(true);
    	 */
    	
    	RobotMap.imu.zeroYaw();
    	
    	RobotMap.driveBaseLeftFrontMotor.enableBrakeMode(false);
    	RobotMap.driveBaseRightFrontMotor.enableBrakeMode(false);
    	RobotMap.driveBaseLeftRearMotor.enableBrakeMode(false);
    	RobotMap.driveBaseRightRearMotor.enableBrakeMode(false);

        Scheduler.getInstance().add((Command) oi.pattern.getSelected());
    }

    /**
     * This function is called periodically during autonomous
     */
    public void autonomousPeriodic() {
    	SmartDashboard.putNumber("Air Pressure", RobotMap.pneumaticsPressure.getAverageVoltage());
    	SmartDashboard.putNumber("Gyro Reading", RobotMap.imu.getYaw());
    	Scheduler.getInstance().run();
 //       oi.prefs.putDouble("test", Math.random());
    }

    public void teleopInit() {
        // This makes sure that the autonomous stops running when
        // teleop starts running. If you want the autonomous to 
        // continue until interrupted by another command, remove
        // this line or comment it out.
        if (autonomousCommand != null)
        	autonomousCommand.cancel();
        mecanumFOD = new MecanumFOD();
        mecanumROD = new MecanumROD();
        int driveMode = (Integer) oi.driveMode.getSelected();
        if (driveMode == 1)
        	Scheduler.getInstance().add(mecanumFOD);
        else 
        	Scheduler.getInstance().add(mecanumROD);
    }

    /**
     * This function is called periodically during operator control
     */
    public void teleopPeriodic() {
    	// TODO: Debug, remove
    	SmartDashboard.putNumber("getPos()", RobotMap.forkliftMotor.getPosition());
    	SmartDashboard.putNumber("Air Pressure", RobotMap.pneumaticsPressure.getAverageVoltage());
    	
    	SmartDashboard.putNumber("Gyro Reading", RobotMap.imu.getYaw());
    	
    	Preferences.getInstance().putDouble("WinchLevel", RobotMap.forkliftMotor.get() / LiftControl.pulsePerMeter);
    	
    	SmartDashboard.putData(Scheduler.getInstance());
    	
		int driveMode = (Integer) oi.driveMode.getSelected();
		if (driveMode == 1)
			Scheduler.getInstance().add(mecanumFOD);
		else 
			Scheduler.getInstance().add(mecanumROD);
    	try {
			camera.getImage(img);
			cs.setImage(img );
    	} catch (Exception e) {
    		// sigh
    	}
    	
		//gamepad Controls
		switch (oi.joystick.getPOV()) {
		//D-pad right
		case 90:
			if (!povPressed)
				Scheduler.getInstance().add(new OpenFork());
			povPressed = true;
			break;
		//D-pad left
		case 270:
			if (!povPressed)
				Scheduler.getInstance().add(new CloseFork());
			povPressed = true;
			break;
		//D-pad up
		case 0:
			// Use speed mode if not currently used
			if (!povPressed) {
				RobotMap.forkliftMotor.changeControlMode(CANTalon.ControlMode.Speed);
				RobotMap.forkliftMotor.enableControl();
			}
			RobotMap.forkliftMotor.set(0.7 * RobotMap.ENCODER_PULSE_PER_METER);
			
			povPressed = true;
			break;
		//D-pad down
		case 180:
			if (!povPressed) {
				RobotMap.forkliftMotor.changeControlMode(CANTalon.ControlMode.Speed);
				RobotMap.forkliftMotor.enableControl();
			}
			RobotMap.forkliftMotor.set(-0.5 * RobotMap.ENCODER_PULSE_PER_METER);
			
			povPressed = true;
			break;
		case -1:
			if (RobotMap.forkliftMotor.getControlMode() == CANTalon.ControlMode.Speed) {
				RobotMap.forkliftMotor.changeControlMode(CANTalon.ControlMode.Position);
				RobotMap.forkliftMotor.set(RobotMap.forkliftMotor.getPosition());;
			}
			povPressed = false;
			break;
		}
		
		//leftTrigger - expel
		if (oi.joystick.getRawAxis(2) >= .9) {
			RobotMap.leftIngestor.set(1.0 * Preferences.getInstance().getDouble("RollerSpeed", 0.75));
	    	RobotMap.rightIngestor.set(-1.0 * Preferences.getInstance().getDouble("RollerSpeed", 0.75));
	    	
			leftTriggerPressed = true;
		} else {
			leftTriggerPressed = false;
		}
		
		//RightTrigger - intake
		if (oi.joystick.getRawAxis(3) >= .9) {
			RobotMap.leftIngestor.set(-1.0 * Preferences.getInstance().getDouble("RollerSpeed", 0.75));
	    	RobotMap.rightIngestor.set(1.0 * Preferences.getInstance().getDouble("RollerSpeed", 0.75));
	    	
			rightTriggerPressed = true;
		} else {
			rightTriggerPressed = false;
		}
		
		//Back Button
		if(back.get() != backPressed) { //check rising edge eg. button is now pressed
			if(backPressed == false) { //this case is when the button is NOW pressed
				RobotMap.leftIngestor.set(1.0 * Preferences.getInstance().getDouble("RollerSpeed", 0.75));
				RobotMap.rightIngestor.set(1.0 * Preferences.getInstance().getDouble("RollerSpeed", 0.75));
				backPressed = true; //set boolean to true, since it's now being pressed
			} else { //this case is when the button has been depressed
				RobotMap.leftIngestor.set(0);
		    	RobotMap.rightIngestor.set(0);
		    	backPressed = false;
			}	
		}
				
		//Start Button
		if(start.get() != startPressed) { //check rising edge eg. button is now pressed
			if(startPressed == false) { //this case is when the button is NOW pressed
				RobotMap.leftIngestor.set(-1.0 * Preferences.getInstance().getDouble("RollerSpeed", 0.75));
				RobotMap.rightIngestor.set(-1.0 * Preferences.getInstance().getDouble("RollerSpeed", 0.75));
				startPressed = true; //set boolean to true, since it's now being pressed
			} else { //this case is when the button has been depressed
				RobotMap.leftIngestor.set(0);
		    	RobotMap.rightIngestor.set(0);
		    	startPressed = false;
			}	
		}
		
		if (!rightTriggerPressed && !leftTriggerPressed && !backPressed && !startPressed) {
			RobotMap.leftIngestor.set(0);
	    	RobotMap.rightIngestor.set(0);}
		
    	DriveEncoders.getEncoderDistance(DriveEncoders.getInitialEncoderValues());
    	
    	if (Preferences.getInstance().getBoolean("RunMoveDistance", false)) {
    		Scheduler.getInstance().add(new MoveDirection(
    				Preferences.getInstance().getDouble("MoveDirectionAngle", 0),
    				Preferences.getInstance().getDouble("MoveDirectionDistance_m", 0),
    				Preferences.getInstance().getDouble("MoveDirectionTurnSpeed", 0),
    				Preferences.getInstance().getDouble("MoveDirectionDriveSpeed", 0)));
    		
    		Preferences.getInstance().putBoolean("RunMoveDistance", false);
    	}
    	
    	
        Scheduler.getInstance().run();
    }
    
    @Override
    public void testInit() {
    	
    }

    /**
     * This function is called periodically during test mode
     */
    public void testPeriodic() {
        LiveWindow.run();
    }
}
